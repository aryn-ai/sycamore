#!/usr/bin/python3

import sys
import struct
from typing import NamedTuple

FMT = "BxxxIQQQQQ48s"
SIZE = struct.calcsize(FMT)

class TimeTraceRec(NamedTuple):
    thread: int
    t0: int
    t1: int
    utime: int
    stime: int
    rss: int
    name: str

def buf_to_rec(buf) -> TimeTraceRec:
    tup = struct.unpack(FMT, buf)
    ver, thr, t0, t1, user, syst, rss, name = tup
    assert ver == 0
    name = name.decode().rstrip('\0')
    return TimeTraceRec(thr, t0, t1, user, syst, rss, name)

def tt_reader(paths: list[str]):
    for path in paths:
        with open(path, "rb") as fp:
            while True:
                buf = fp.read(SIZE)
                if not buf:
                    break
                yield buf_to_rec(buf)

class Foo:
    def run(self, paths):
        first = 999999999999.0
        last = 0
        utime = 0
        stime = 0
        rss = 0
        thread_wall = {}
        thread_cpu = {}
        name_wall = {}
        name_cpu = {}

        for rec in tt_reader(paths):
            t0 = rec.t0 / 1000000000.0
            t1 = rec.t1 / 1000000000.0
            rutime = rec.utime / 1000000000.0
            rstime = rec.stime / 1000000000.0
            wall = t1 - t0
            first = min(first, t0)
            last = max(last, t1)
            utime += rutime
            stime += rstime
            rss = max(rss, rec.rss)
            cpu = rutime + rstime
            val = thread_wall.get(rec.thread, 0)
            thread_wall[rec.thread] = val + wall
            val = thread_cpu.get(rec.thread, 0)
            thread_cpu[rec.thread] = val + cpu
            val = name_wall.get(rec.name, 0)
            name_wall[rec.name] = val + wall
            val = name_cpu.get(rec.name, 0)
            name_cpu[rec.name] = val + cpu

        wall = last - first
        cpu = utime + stime
        frac = cpu / wall
        ufrac = utime / cpu
        sfrac = stime / cpu
        megs = rss / 1048576.0
        print(f"wall={wall}")
        print(f"cpu={cpu} ({frac:.3f})")
        print(f"utime={utime} ({ufrac:.3f})")
        print(f"stime={stime} ({sfrac:.3f})")
        print(f"maxrss={megs}")
        for k, v in thread_wall.items():
            frac = v / wall
            print(f"{k}={v:.6f} ({frac:.3f})")
        for k, v in name_wall.items():
            frac = v / wall
            print(f"{k}={v:.6f} ({frac:.3f})")
        for k, v in thread_cpu.items():
            frac = v / cpu
            print(f"{k}={v:.6f} ({frac:.3f})")
        for k, v in name_cpu.items():
            frac = v / cpu
            print(f"{k}={v:.6f} ({frac:.3f})")

    def overlap(self, paths):
        events = []
        for rec in tt_reader(paths):
            events.append((rec.t0, 1))
            events.append((rec.t1, 0))
        events.sort()
        level = 0
        last = events[0][0]
        sums = {}
        for event_time, is_start in events:
            dur = event_time - last
            val = sums.get(level, 0)
            sums[level] = val + dur
            if is_start:
                level += 1
            else:
                level -= 1
            last = event_time
        inv = [(b, a) for a, b in sums.items()]
        inv.sort()
        for event_time, lev in inv:
            secs = event_time / 1000000000.0
            print(f"{lev}={secs}")

def main(args = None):
    if args is None:
        args = sys.argv[1:]
    foo = Foo()
    foo.run(args)
    foo.overlap(args)
    return 0


if __name__ == "__main__":
    sys.exit(main())
